## Motivation

This RFC proposes a **declarative output API** for `evmPortalSource` in Pipes SDK.

The new API replaces the current **implicit, order-dependent query extraction** mechanism with an explicit and deterministic model in which:

* all logical outputs are declared directly on the source
* query construction happens **once, upfront**
* transformers may declare query requirements **without relying on pipeline position**
* a single portal query is executed and its results are routed into named streams

---

## Background and problems

Today, some transformers (for example `evmDecoder`) implicitly modify the source query **based on their position in the pipeline**.

```ts
source()
  .pipe(evmDecoder()) // must be placed immediately after the source
  .pipe(otherStuff())
```

This creates several issues that are hard to reason about and difficult to document.

### Problems

1. **Hidden behavior**
   Query construction is affected by pipeline structure in non-obvious ways.

2. **Order dependence**
   Moving a transformer even one step downstream can silently change the executed query.

3. **Poor debuggability**
   It is unclear which transformer contributed which part of the final query.

4. **High cognitive load**
   Users must remember implicit placement rules instead of reading configuration.

5. **Limited extensibility**
   Adding new query-aware transformers increases coupling between transformers and source internals.

---

## Goals

* Make query construction **explicit, deterministic, and inspectable**
* Remove ordering constraints between sources and transformers
* Allow multiple logical outputs from a single source execution
* Preserve the ability for transformers to declare query requirements
* Improve composability and documentation clarity

---

## Non-goals

* Redesigning the EVM query format
* Changing the portal protocol

---

## Proposed solution: Declarative Streams

Introduce a new `streams` field in `evmPortalSource` configuration.

```ts
evmPortalSource({
  portal: '...',
  outputs: { ... }
})
```

Each entry in `streams` defines a **named logical output** of the source.

A stream may be defined as:

* a raw query fragment (`EvmQueryBuilder` / `RawPortalData` / `EvmQueryFragment` ?)
* a decoder or transformer (optionally composed as a small pipeline)

The source becomes responsible for:

1. collecting all query fragments
2. collecting all query requirements declared by transformers
3. merging them into a **single final EVM query**
4. executing that query exactly once
5. routing incoming data into named streams

---

## Example


```ts

function evmDecoder() {
  return evmQuery().addLogs( /* .add topics. */ ).build(/* */)
}

const source = evmPortalSource({
  portal: '...',
  outputs: {
    // raw blockchain data
    raw: evmQuery()
      .addLog({ 
        range: { from: 0 }, 
        request: { topic0: [commonAbis.erc20.events.Transfer.topic] }
      })
      .build((data) => data) // entering into transofrmation steps
      .transform(data => data),

    // decoded ERC20 transfers
    transfers: evmDecoder({
      range: { from: 'latest' },
      events: {
        transfers: commonAbis.erc20.events.Transfer,
      },
    }).transform(data => data.transfers),
  },
})

await source
  .transform(({ raw, transfers, latency }, ctx) => {
    // consume multiple streams simultaneously
    return { raw, transfers, latency }
  })
  .pipeTo(target)
```

---

## Output

Each entry in `outputs` must return a **stream definition**.

A stream definition is an object that:

1. Contributes a fragment to the final EVM query, and
2. Produces a typed stream of data that can be further transformed.

In practice, this is created by calling `evmQuery()` and optionally attaching transformations.

### Minimal form (raw data)

```ts
evmQuery()
```

This declares a stream that only contributes to the query and outputs the raw portal data for that fragment.

### With decoding / transformation

```ts
evmQuery()
  .addLogs(...)
  .build((data) => decodedData)   // decode or reshape portal response
  .transform((data) => enriched) // optional additional transformation
```

Here:

- `evmQuery()` defines **what to fetch**
- `.build(...)` defines **how to decode / map portal data**
- `.transform(...)` defines **additional pure transformations** on the stream output

The final result of this chain is what you assign as a value in `outputs`.

### Example

```ts
const source = evmPortalSource({
  portal: '...',
  outputs: {
    raw: evmQuery(),

    transfers: evmQuery()
      .addLogs({ ... })
      .build(decodeTransfers)
      .transform(enrichWithMetadata),
  },
})
```

Each key in `outputs` becomes a named stream available to downstream transformers.
---

## Query construction model

The source performs the following steps:

1. Iterate over all declared streams
2. Collect:
    * all `QueryBuilder` fragments
    * all query contributions declared by transformers
3. Merge them into a single query plan
4. Execute the query once against the portal
5. Dispatch results to streams

**Query construction is deterministic and independent of pipeline ordering.**

---

## Open questions

* Should factory pre-indexing be part of the query construction model?
  (Pre-index modifies the query but is conceptually different from decoders.)

* Type safety:

    * How to prevent EVM-specific decoders from being used with non-EVM sources (e.g. Solana)?

* API surface:

    * Can decoders and transformers be split more clearly into query-aware and query-agnostic layers?

---

## Expected impact

* Predictable query construction
* Improved debuggability and introspection
* Lower a cognitive load for users
* Cleaner extension points for future transformers
* Stronger guarantees around single-query execution
