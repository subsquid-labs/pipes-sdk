# Pipes SDK examples
Official documentation: https://beta.docs.sqd.dev/en/sdk/pipes-sdk/evm.autogenerated/quickstart

## Generating Custom ABIs
Generate the typescript files for the contract 0x000000000004444c5dc75cB358380D2e3dE08A90 deployed on Ethereum mainnet and store under `./contracts/`
This step is necessary to use the `evmDecoder` and `factory` feature mentioned below.
For ERC20, the Pipes SDK provides the `commonAbis`(@subsquid/pipes/evm) objects, containing the ABI for ERC20 tokens, therefore this step is not necessary
```sh
npx @subsquid/evm-typegen@latest contracts/ 0x000000000004444c5dc75cB358380D2e3dE08A90 --chain-id 1
```

## Basic pipes example
Basic example demonstrating how to use pipes for processing EVM data.
This example shows how to:
- Create a data stream from Base Mainnet using Portal API
- Decode ERC20 transfer events
- Process the transformed events in a streaming fashion

```ts
import { commonAbis, evmDecoder, evmPortalSource } from '@subsquid/pipes/evm'

async function cli() {
  const stream = evmPortalSource({
    portal: 'https://portal.sqd.dev/datasets/ethereum-mainnet',
  }).pipe(
    evmDecoder({
      range: { from: 'latest' },
      events: {
        transfers: commonAbis.erc20.events.Transfer,
      },
    }),
  )

  for await (const { data } of stream) {
    console.log(data.transfers.length)
  }
}

void cli()
```

## Event decoding
Use the `evmDecoder` to decode any event from contracts. If not an ERC20 contract, refer to [Generating Custom ABIs](#generating-custom-abis) section
Use case: Decode ERC20 token transfers with typed event data.
_See more at: https://beta.docs.sqd.dev/en/sdk/pipes-sdk/evm.autogenerated/guides/factory-pattern_
```ts
import {
  evmPortalSource,
  evmDecoder,
  commonAbis,
} from "@subsquid/pipes/evm";

async function main() {
  const source = evmPortalSource({
    portal: "https://portal.sqd.dev/datasets/ethereum-mainnet",
  });

  const decoder = evmDecoder({
    range: { from: 20000000, to: 20000100 },
    contracts: ["0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"], // USDC
    events: {
      transfer: commonAbis.erc20.events.Transfer,
    },
  });

  for await (const { data } of source.pipe(decoder)) {
    for (const t of data.transfer) {
      console.log({
        from: t.event.from,
        to: t.event.to,
        value: t.event.value.toString(),
        block: t.block.number,
        tx: t.rawEvent.transactionHash,
      });
    }
  }
}

void main();
```

## Combining pipes
This example demonstrates how to combine multiple data processing pipes
to handle both ERC20 transfers and Uniswap V3 swaps simultaneously.
It uses Portal API to stream data from Base Mainnet and processes
the data in batches while tracking statistics for each type of transaction.

```ts
import { evmPortalSource, factorySqliteDatabase } from '@subsquid/pipes/evm'
import { erc20Transfers, uniswapV3, uniswapV3Decoder } from './decoders'

async function cli() {
  // Define block range for data processing
  const range = { from: '20,000,000', to: '+1,000' }

  // Create a combined stream that processes both ERC20 transfers and Uniswap V3 swaps
  // from Base Mainnet using Portal API
  const stream = evmPortalSource({
    portal: 'https://portal.sqd.dev/datasets/base-mainnet',
  }).pipeComposite({
    transfers: erc20Transfers({
      range: { from: '20,000,000', to: '+1,000' },
    }),
    uniswapV3: uniswapV3Decoder({
      range,
      factory: {
        address: uniswapV3.base.mainnet.factory,
        database: factorySqliteDatabase({ path: './uniswap-v3-pools.sqlite' }),
      },
    }),
  })

  // Process streamed data and log statistics for each batch
  // - data.transfers contains processed ERC20 transfers
  // - data.uniswapV3.swaps contains processed Uniswap V3 swaps
  for await (const { data } of stream) {
    console.log('-------------------------------------')
    console.log(`parsed ${data.transfers.length} transfers`)
    console.log(`parsed ${data.uniswapV3.swaps.length} swaps`)
    console.log('-------------------------------------')
  }
}

void cli()
```

## Factory example
This example demonstrates how to use a Factory pattern to decode Uniswap V3 swaps.
It creates an EVM Portal Source to stream Ethereum mainnet data, sets up a Factory
to track pool creation events, and decodes swap events from the created pools.
The pool addresses are stored in an SQLite database for efficient lookup.
Akin to `evmDecoder` the `factory` also depends on generating the contract ABIs from the typegen CLI. Refer to [Generating Custom ABIs](#generating-custom-abis) section
_See more at: https://beta.docs.sqd.dev/en/sdk/pipes-sdk/evm.autogenerated/guides/factory-pattern_
```ts
import { DecodedEvent, evmDecoder, evmPortalSource, factory, factorySqliteDatabase } from '@subsquid/pipes/evm'
import { events as factoryAbi } from './abi/uniswap.v3/factory'
import { events as swapsAbi } from './abi/uniswap.v3/swaps'

async function cli() {
  const stream = evmPortalSource({
    portal: 'https://portal.sqd.dev/datasets/ethereum-mainnet',
  }).pipe(
    evmDecoder({
      range: { from: '12,369,621' },
      contracts: factory({
        address: '0x1f98431c8ad98523631ae4a59f267346ea31f984',
        event: factoryAbi.PoolCreated,
        parameter: 'pool',
        database: factorySqliteDatabase({
          path: './uniswap3-eth-pools.sqlite',
        }),
      }),
      events: {
        swaps: swapsAbi.Swap,
        fees: swapsAbi.SetFeeProtocol,
      },
    }),
  )

  for await (const { data } of stream) {
    console.log(`parsed ${data.swaps.length} swaps and ${data.fees.length} fees`)
  }
}

void cli()
```

## Factory filtering by event param
Track only specific factory-created contracts by filtering creation events.
Use case: Reduce data transfer and processing by filtering factory events at the source.
Akin to `evmDecoder` the `factory` also depends on generating the contract ABIs from the typegen CLI. Refer to [Generating Custom ABIs](#generating-custom-abis) section.
_See more at: https://beta.docs.sqd.dev/en/sdk/pipes-sdk/evm.autogenerated/guides/factory-pattern_
```ts
import {
  evmPortalSource,
  evmDecoder,
  factory,
  factorySqliteDatabase,
} from "@subsquid/pipes/evm";
import { createTarget } from "@subsquid/pipes";
import * as factoryAbi from "./abi/uniswap-v3-factory";
import * as poolAbi from "./abi/uniswap-v3-pool";

async function main() {
  const WETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
  
  const source = evmPortalSource({
    portal: "https://portal.sqd.dev/datasets/ethereum-mainnet",
  });

  const decoder = evmDecoder({
    range: { from: 12369621 },
    contracts: factory({
      address: "0x1f98431c8ad98523631ae4a59f267346ea31f984",
      event: {
        event: factoryAbi.events.PoolCreated,
        params: {
          token0: WETH, // Only pools with WETH as token0
        },
      },
      parameter: "pool",
      database: factorySqliteDatabase({
        path: "./uniswap-v3-weth-pools.sqlite",
      }),
    }),
    events: {
      swap: poolAbi.events.Swap,
    },
  });

  const target = createTarget({
    write: async ({ logger, read }) => {
      for await (const { data } of read()) {
        logger.info(`Parsed ${data.swap.length} swaps from WETH pools`);
      }
    },
  });

  await source.pipe(decoder).pipeTo(target);
}

void main();
```

## Clickhouse target example
```ts
import { createClient } from '@clickhouse/client'
import { commonAbis, evmDecoder, evmPortalSource } from '@subsquid/pipes/evm'
import { clickhouseTarget } from '@subsquid/pipes/targets/clickhouse'

async function main() {
  await evmPortalSource({
    portal: 'https://portal.sqd.dev/datasets/ethereum-mainnet',
  })
    .pipe(
      evmDecoder({
        range: { from: 'latest' },
        events: {
          transfers: commonAbis.erc20.events.Transfer,
        },
      }),
    )
    .pipe((data) =>
        data.transfers.map((t) => ({
          block_number: t.block.number,
          token: t.contract,
          from: t.event.from,
          to: t.event.to,
          amount: t.event.value.toString(),
    })))
    .pipeTo(
      clickhouseTarget({
        client: createClient({
          username: 'default',
          password: 'password',
          url: 'http://localhost:8123',
        }),
        onStart: async ({ store }) => {
          await store.command({
            query: `
              CREATE TABLE IF NOT EXISTS erc20_transfers (
                block_number  UInt64,
                timestamp     DateTime64(3) CODEC (DoubleDelta, ZSTD),
                token         String,
                from          String,
                to            String,
                amount        UInt256
              )
              ENGINE = MergeTree
              ORDER BY block_number
          `,
          })
        },
        onData: async ({ ctx, data, store }) => {
          await store.insert({
            table: 'erc20_transfers',
            values: data,
            format: 'JSONEachRow',
          })
        },
        onRollback: async ({ safeCursor, store }) => {
          await store.removeAllRows({
            tables: ['erc20_transfers'],
            where: `block_number > {latest:UInt32}`,
            params: { latest: safeCursor.number },
         })
        },
      }),
    )
}

void main()
```

## Query builder to fetch more than event logs
```ts
import { EvmQueryBuilder, evmPortalSource, commonAbis } from "@subsquid/pipes/evm";

// Some real, well-known addresses/hashes for a concrete example:
const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const USDT = "0xdac17f958d2ee523a2206206994597c13d831ec7";
const DAI  = "0x6b175474e89094c44da98b954eedeac495271d0f";

// ERC-20 Transfer(address,address,uint256)
const TRANSFER_TOPIC0 =
  "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef";

// Example: only transfers where the indexed `from` equals this address (topic1)
const FROM_ADDRESS = "0x1111111111111111111111111111111111111111";
const FROM_TOPIC1 = padTopicAddress(FROM_ADDRESS);

// ERC-20 transfer(address,uint256) function selector (sighash)
const TRANSFER_SIGHASH = "0xa9059cbb";

const query = new EvmQueryBuilder()
  // All field-selection options shown on the Query Builder page
  .addFields({
    block: {
      number: true, // required
      hash: true,   // required
      parentHash: true,
      timestamp: true,
      size: true,
      gasUsed: true,
      gasLimit: true,
      baseFeePerGas: true,
    },
    log: {
      address: true,
      data: true,
      topics: true,
      transactionHash: true,
      transactionIndex: true,
      logIndex: true,
      removed: true,
    },
    transaction: {
      hash: true,
      from: true,
      to: true,
      value: true,
      input: true,
      gas: true,
      gasPrice: true,
      maxFeePerGas: true,
      maxPriorityFeePerGas: true,
      nonce: true,
    },
  })
  // Uses every log filter key shown: address + topic0 + topic1 (+ range.from/to)
  .addLog({
    request: {
      address: [USDC, USDT, DAI],
      topic0: [commonAbis.erc20.transfer.topic],
    },
    range: {
      from: 20_000_000,
      to: 20_000_100,
    },
  })
  // Uses every transaction filter key shown: from + to + sighash (+ range.from)
  .addTransaction({
    request: {
      from: [FROM_ADDRESS],
      to: [USDC], // just an example "recipient"
      sighash: [commonAbis.erc20.transfer.topic],
    },
    range: { from: 20_000_000 },
  });

export const source = evmPortalSource({
  portal: "https://portal.sqd.dev/datasets/ethereum-mainnet",
  query,
});
```

## Creating a transformer

This should only be used when it's not possible to get the desired outcome straight from transactions
or logs, but instead the dataset being built depend on the combination of both

```ts
async function main() {
// Start with empty query in source
const source = evmPortalSource({
  portal: "https://portal.sqd.dev/datasets/ethereum-mainnet",
  query: new EvmQueryBuilder(),
});

// Transformer specifies its own data requirements
const usdcTransformer = createTransformer({
  query: ({ queryBuilder }) => {
    queryBuilder
      .addFields({
        block: { number: true, hash: true },
        log: { address: true, topics: true, data: true, transactionHash: true },
      })
      .addLog({
        request: {
          address: ["0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"],
          topic0: [
            "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          ],
        },
        range: { from: 20000000, to: 20000000 },
      });
  },
  transform: async (data) => {
    // function that will combine the data from the logs and the txs
  },
});

await source.pipe(usdcTransformer).pipeTo(target);
}

void main();
```
